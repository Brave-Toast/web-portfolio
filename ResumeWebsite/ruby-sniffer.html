<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project: Ruby Packet Sniffer | [Your Name]</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;600&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Navigation -->
    <nav>
        <div class="logo">./project_details</div>
        <ul class="nav-links">
            <li><a href="index.html"><i class="fas fa-arrow-left"></i> cd .. (Home)</a></li>
        </ul>
    </nav>

    <!-- Project Header -->
    <header class="project-hero">
        <div class="container">
            <span class="tag">Ruby</span>
            <span class="tag">Raw Sockets</span>
            <span class="tag">TCP/IP</span>
            <span class="tag">Bitwise Operations</span>
            <h1>Raw Socket Packet Analyzer</h1>
            <p class="subtitle">A manual implementation of a TCP sniffer using native Ruby system calls to unpack binary IP headers and detect handshake flags.</p>
            
            <div class="project-links">
                <!-- Link this to your actual GitHub repo later -->
                <a href="https://github.com/Brave-Toast/ruby-packet-sniffer" class="btn primary"><i class="fab fa-github"></i> View Source Code</a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container project-content">
        
        <!-- The Objective -->
        <section class="content-block">
            <h3>01. The Objective</h3>
            <p>While tools like Wireshark and Scapy abstract away the complexity of network traffic, I wanted to understand how data is actually structured on the wire. I built this tool to manually interface with the Linux kernel's Network Interface Controller (NIC) using <strong>Raw Sockets</strong>, bypassing the operating system's standard TCP/IP stack processing to inspect binary packets directly.</p>
        </section>

        <!-- Technical Implementation -->
        <section class="content-block">
            <h3>02. Technical Implementation</h3>
            <p>The script creates a <code>PF_INET</code> socket to listen for TCP traffic. Unlike high-level libraries, this required manually parsing the binary data stream:</p>
            <ul class="tech-list">
                <li><strong>Binary Unpacking:</strong> I used Ruby's <code>unpack</code> method to read the first 20 bytes of the IP header, extracting the Source and Destination IPs from specific byte offsets (12-15 and 16-19).</li>
                <li><strong>Dynamic Header Analysis:</strong> Because IP headers can vary in length, I had to calculate the <strong>Internet Header Length (IHL)</strong> dynamically (<code>(version_byte & 0x0F) * 4</code>) to accurately locate the start of the TCP header.</li>
                <li><strong>Bitwise Flag Detection:</strong> To identify a "SYN" packet, I isolated the 13th byte of the TCP header and performed a bitwise AND operation (<code>flags & 0x02</code>) to check if the SYN bit was set to 1.</li>
            </ul>
        </section>

        <!-- Code Highlight -->
        <section class="content-block">
            <h3>03. Key Logic: Bitwise Flag Extraction</h3>
            <p>The core of the detection engine relies on bitwise operations to read the TCP Control Flags from the binary stream.</p>
            <div class="code-window">
                <div class="window-header">
                    <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
                    <span class="title">simple_sniffer.rb</span>
                </div>
                <pre><code>
# Extract the 13th byte containing TCP Control Flags
flags_byte = tcp_header[13].unpack('C').first

# Use Bitwise AND to isolate specific bits
# 0x02 is binary 0000 0010 (SYN bit)
# 0x10 is binary 0001 0000 (ACK bit)
is_syn = (flags_byte & 0x02) != 0  
is_ack = (flags_byte & 0x10) != 0  

if is_syn
  # If ACK is also set, it's a response (SYN-ACK)
  type = is_ack ? "SYN-ACK (Response)" : "SYN (Request)"
  puts "[!] #{type} Detected: #{source_ip} -> #{dest_ip}"
end
                </code></pre>
            </div>
        </section>

        <!-- Challenges -->
        <section class="content-block">
            <h3>04. Challenges & Solutions</h3>
            <div class="challenge-card">
                <h4>The "Invisible" Outbound Traffic</h4>
                <p><strong>Challenge:</strong> When testing the sniffer, I initially saw zero traffic when running a <code>curl</code> command, even though the connection was successful. I discovered that on Linux, raw sockets bound to <code>ETH_P_IP</code> often only receive <em>incoming</em> frames by default, meaning my script was blind to my own outbound SYN packets.</p>
                <p><strong>Solution:</strong> I refactored the detection logic to identify <strong>SYN-ACK</strong> (Response) packets as well as SYN (Request) packets. By checking for the ACK flag (<code>0x10</code>), I was able to infer the full handshake state by seeing the server's response, effectively validating that my outbound traffic was successful.</p>
            </div>
        </section>

    </main>

    <footer>
        <p>&copy; 2025 James Mulhall. <a href="index.html">Return to Home</a></p>
    </footer>

</body>
</html>