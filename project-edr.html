<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project: Python EDR | [Your Name]</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;600&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
</head>
<body>

    <nav>
        <div class="logo">./project_details</div>
        <ul class="nav-links">
            <li><a href="index.html"><i class="fas fa-arrow-left"></i> cd .. (Home)</a></li>
        </ul>
    </nav>

    <header class="project-hero">
        <div class="container">
            <span class="tag">Python 3</span>
            <span class="tag">Multiprocessing</span>
            <span class="tag">Scapy</span>
            <span class="tag">Watchdog</span>
            <h1>Custom Linux EDR Agent</h1>
            <p class="subtitle">A modular, multi-process Endpoint Detection & Response agent built to detect SYN floods, SSH brute-forcing, and reverse shells.</p>
            
            <div class="project-links">
                <a href="https://github.com/Brave-Toast/Team9_EDR" class="btn primary"><i class="fab fa-github"></i> View Source Code</a>
            </div>
        </div>
    </header>

    <main class="container project-content">
        
        <section class="content-block">
            <h3>01. The Objective</h3>
            <p>Commercial EDRs are "black boxes." To understand how they work under the hood, I built a custom agent from scratch in Python. The goal was to create a system that could monitor multiple attack vectors simultaneously without blocking the main execution thread. It needed to detect <strong>Network anomalies</strong> (SYN floods), <strong>File Integrity changes</strong>, and <strong>Process anomalies</strong> (Reverse Shells).</p>
        </section>

        <section class="content-block">
            <h3>02. Architecture</h3>
            <p>The agent uses a <strong>Multi-Process Architecture</strong>. Instead of threading (which is limited by Python's Global Interpreter Lock), each monitor runs in its own isolated process using the `multiprocessing` library. They communicate via a central `ThreatBus` queue.</p>
            
            <ul class="tech-list">
                <li><strong>Core Agent:</strong> Orchestrates lifecycles and handles logging (ECS Format).</li>
                <li><strong>Network Monitor:</strong> Uses <code>scapy</code> to sniff TCP packets for SYN floods.</li>
                <li><strong>Process Monitor:</strong> Uses <code>psutil</code> to detect reverse shell arguments (e.g., <code>nc -e /bin/sh</code>).</li>
                <li><strong>File Monitor:</strong> Uses <code>watchdog</code> to track changes to <code>/etc/passwd</code> and web directories.</li>
            </ul>
        </section>

        <section class="content-block">
            <h3>03. Key Logic: Process Baselining</h3>
            <p>One of the most efficient features is the Process Monitor. Instead of scanning every process constantly, it calculates a "Set Difference" to find only <em>new</em> processes spawned since the last check.</p>
            
            <div class="code-window">
                <div class="window-header">
                    <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
                    <span class="title">EDR/monitors/process_monitor.py</span>
                </div>
                <pre><code>
def run(self):
    # Snapshot existing processes on startup (Baseline)
    self.known_pids = set(psutil.pids())

    while not self.shutdown_event.is_set():
        current_pids = set(psutil.pids())
        
        # Set subtraction: Only analyze NEW processes
        new_pids = current_pids - self.known_pids

        for pid in new_pids:
            proc = psutil.Process(pid)
            cmdline = " ".join(proc.cmdline())
            
            # Regex check for Reverse Shells
            if re.search(r"\b(nc|ncat)\b", cmdline) and re.search(r"\b-e\b", cmdline):
                self.log_alert("REVERSE-SHELL", f"Critical: {cmdline}")

        self.known_pids = current_pids
        self.shutdown_event.wait(self.interval)
                </code></pre>
            </div>
        </section>

        <section class="content-block">
            <h3>04. Challenges & Solutions</h3>
            
            <div class="challenge-card">
                <h4>Reducing False Positives</h4>
                <p>One major hurdle was distinguishing between legitimate system activity and actual threats. Initially, the SSH monitor flagged every failed login, creating noise during simple typos. I implemented a <strong>time-windowed threshold logic</strong>, which only alerts after 5 failed attempts within 5 minutes. Similarly, the Process Monitor uses the baselining logic shown above to filter out background daemons, reducing CPU overhead by over 80%.</p>
            </div>

            <div class="challenge-card">
                <h4>Privilege Management</h4>
                <p>The Network Monitor requires raw socket access to sniff packets. I added a check using <code>os.geteuid()</code> to gracefully degrade functionality. If the agent isn't run as root/sudo, it disables the network sniffer but keeps the File and Process monitors active, ensuring the agent doesn't crash entirely.</p>
            </div>
        </section>

    </main>

    <footer>
        <p>&copy; 2025 James Mulhall. <a href="index.html">Return to Home</a></p>
    </footer>

</body>
</html>